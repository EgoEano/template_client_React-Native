# Техническое условие использования проекта miniHabit

## 1. Общие положения

Настоящее техническое условие определяет требования к использованию инструментов, компонентов и структуры модулей в проекте miniHabit. Все разработчики должны следовать данным требованиям для обеспечения единообразия кода и архитектуры проекта.

Этот документ является строгим архитектурным контрактом.
Весь сгенерированный код обязан следовать этим правилам.

---

## 2. Использование инструментов и компонентов из `client/core`

### 2.1. Приоритет использования встроенных инструментов

**КРИТИЧЕСКИ ВАЖНО**: Перед использованием любых сторонних библиотек и инструментов необходимо в первую очередь проверить наличие соответствующего функционала в `client/core`. Использование встроенных инструментов является **обязательным** для всех задач, которые они способны покрывать.

---

### 2.2. Сервисы (`client/core/services`)

#### 2.2.1. Провайдеры (`client/core/services/providers`)

**Обязательные к использованию:**

##### `styleProvider.tsx`

- **Назначение**: Управление темами, стилями и адаптивностью интерфейса
- **Когда использовать**:
    - Для всех стилизаций компонентов
    - При необходимости доступа к текущей теме приложения
    - Для создания адаптивных стилей (compact/spacious)
    - При регистрации новых стилей для компонентов
- **Хуки**: `useStyleContext()`
- **API**:
    - `theme` - доступ к текущей теме (tokens, semantics, components)
    - `dimensions` - размеры экрана (width, height, visibleWidth, visibleHeight)
    - `styles` - зарегистрированные стили с учетом категории экрана
    - `addTheme()` - добавление новой темы
    - `selectTheme()` - переключение темы
    - `add()` - регистрация стилей компонента
    - `addGroup()` - групповая регистрация стилей

**Требование**: **ЗАПРЕЩЕНО** использовать `StyleSheet.create()` напрямую без использования `theme` из `useStyleContext()`. Все стили должны быть адаптивными и использовать токены темы.

##### `notificationProvider.tsx`

- **Назначение**: Централизованное управление уведомлениями и диалогами
- **Когда использовать**:
    - Для отображения уведомлений пользователю
    - Для показа диалоговых окон с подтверждением
    - Вместо нативных `alert()` и `confirm()`
- **Хуки**: `useNotification()`
- **API**:
    - `pushNotify(item)` - показать уведомление
    - `pushDialog(item)` - показать диалог (возвращает Promise<boolean>)

**Требование**: **ЗАПРЕЩЕНО** использовать нативные методы `alert()`, `confirm()`, `prompt()`. Вместо этого **обязательно** использовать `notificationProvider`.

##### `storageProvider.tsx`

- **Назначение**: Управление Redux store
- **Когда использовать**:
    - Для доступа к глобальному состоянию приложения
    - При необходимости dispatch действий
- **Требование**: Все слайсы должны быть зарегистрированы в `client/modules/stores.ts`

##### `languageProviderService.tsx`

- **Назначение**: Управление локализацией
- **Когда использовать**:
    - Для всех текстовых строк интерфейса
    - При переключении языка приложения
    - При добавлении новых переводов

##### `mutableDataProvider.tsx`

- **Назначение**: Управление изменяемыми данными между компонентами
- **Когда использовать**:
    - Для передачи данных между несвязанными компонентами
    - Для временного хранения состояния

##### `systemDataProviderService.tsx`

- **Назначение**: Предоставление системных данных приложения
- **Когда использовать**:
    - Для доступа к системной информации (версия, настройки и т.д.)

##### `eventProviderFactory.tsx`

- **Назначение**: Фабрика для создания событийных провайдеров
- **Когда использовать**:
    - При необходимости создания кастомной системы событий

##### `superProviderService.tsx`

- **Назначение**: Обертка для комбинирования множества провайдеров
- **Когда использовать**:
    - Для объединения нескольких провайдеров в один

---

#### 2.2.2. Хранилище (`client/core/services/storage`)

##### `storageService.ts`

- **Назначение**: Кроссплатформенное хранение данных (localStorage для web, AsyncStorage для mobile)
- **Когда использовать**:
    - Для любого постоянного хранения данных
    - Вместо прямого использования `localStorage` или `AsyncStorage`
- **API**:
    - `get<T>(key: string): Promise<T | null>` - получить данные
    - `set<T>(key: string, value: T): Promise<void>` - сохранить данные
    - `remove(key: string): Promise<void>` - удалить данные

**Требование**: **ЗАПРЕЩЕНО** напрямую использовать `localStorage`, `AsyncStorage` или любые другие механизмы хранения. **Обязательно** использовать `storageService`.

---

#### 2.2.3. Хуки (`client/core/services/hooks`)

##### Navigation Adapter

- **Файлы**: `navigationAdapter.native.ts`, `navigationAdapter.web.ts`, `navigationAdapter.d.ts`
- **Назначение**: Кроссплатформенная навигация (react-navigation для native, react-router для web)
- **Когда использовать**:
    - Для всех операций навигации в приложении
- **API**:
    - `useNavigation()` - получить объект навигации
    - `useRoute()` - получить информацию о текущем маршруте

**Требование**: **ЗАПРЕЩЕНО** напрямую импортировать из `@react-navigation/native` или `react-router-dom`. **Обязательно** использовать навигационный адаптер.

##### Back Redirect Adapter

- **Файлы**: `backRedirectAdapter.native.ts`, `backRedirectAdapter.web.ts`, `backRedirectAdapter.d.ts`
- **Назначение**: Кроссплатформенная обработка возврата назад
- **Хук**: `useBackRedirect()`
- **Когда использовать**:
    - При необходимости перехватить действие возврата назад (кнопка "Назад" на Android)

---

#### 2.2.4. Утилиты (`client/core/services/utils`)

##### `customFormatDate.ts`

- **Назначение**: Форматирование дат
- **Когда использовать**: Для всех операций форматирования дат

##### `generators.ts`

- **Назначение**: Генераторы (ID, случайные значения и т.д.)
- **Когда использовать**: При необходимости генерации уникальных идентификаторов

##### `parsers.ts`

- **Назначение**: Парсеры данных
- **Когда использовать**: Для парсинга входящих данных

**Требование**: Перед добавлением сторонних библиотек для работы с датами, генерации ID и парсинга, проверить наличие необходимого функционала в данных утилитах.

---

#### 2.2.5. Сетевые запросы (`client/core/services/connection`)

##### `fetchRequest.ts`

- **Назначение**: Обертка для выполнения HTTP-запросов
- **Когда использовать**: Для всех сетевых запросов в приложении

**Требование**: **ЗАПРЕЩЕНО** использовать нативный `fetch()` или библиотеки типа `axios` напрямую без согласования. **Обязательно** использовать `fetchRequest`.

---

#### 2.2.6. Типизированные ответы (`client/core/services/responses`)

##### `typedResponses.ts`

- **Назначение**: Типизация ответов от сервера
- **Когда использовать**: Для типизации всех API-ответов

### 2.2.7. Обработка ошибок

- Все ошибки UI → через notificationProvider
- Ошибки API → через typedResponses
- Запрещено:
    - console.error в production-коде
    - silent catch без логирования

---

### 2.3. UI компоненты (`client/core/ui`)

#### 2.3.1. Интерфейсные компоненты (`client/core/ui/components/interfaceComponents.tsx`)

**Обязательные к использованию компоненты:**

##### Атомарные компоненты:

- **`Button`** - кнопки (варианты: primary, secondary, success, error, disabled)
- **`Text`** - текстовые элементы (варианты: title, subtitle, body, label)
- **`InputText`** - текстовые поля ввода

##### Молекулярные компоненты:

- **`Modal`** - модальное окно
- **`ModalCard`** - модальное окно с карточкой
- **`View`** - контейнер (с поддержкой прокрутки)
- **`Card`** - карточка
- **`FormContent`** - форма с валидацией

**Требование**: **ЗАПРЕЩЕНО** создавать собственные базовые компоненты (кнопки, инпуты, текст и т.д.) без использования компонентов из `interfaceComponents.tsx`. При необходимости расширения функционала - **обязательно** расширить существующие компоненты или добавить новые варианты в `interfaceComponents.tsx`.

#### 2.3.2. Компоненты уведомлений (`client/core/ui/components/notificationComponents.tsx`)

- **`DialogView`** - диалоговое окно
- **`NotifyView`** - плавающее уведомление

**Требование**: Используются автоматически через `notificationProvider`, не вызывать напрямую.

---

#### 2.3.3. Стили (`client/core/ui/styles`)

##### `themes.ts`

- **Назначение**: Определение тем и токенов
- **Содержит**:
    - `templateTokens` - базовые токены (цвета, размеры, типографика, elevation)
    - `createSemantics()` - создание семантических токенов
    - `createComponents()` - создание стилей компонентов

**Требование**: Все темы должны быть созданы на основе `templateTokens` и зарегистрированы через `styleProvider`.

##### `styles.ts`

- **Назначение**: Дополнительные общие стили

---

#### 2.3.4. Активы (`client/core/ui/assets`)

- **`images/`** - изображения приложения
- **`template.html`** - шаблон HTML для web-версии

---

#### 2.3.5. Локализация (`client/core/ui/locales`)

- **`languages.js`** - список поддерживаемых языков
- **`en-US.js`** - переводы для английского языка

**Требование**: Все новые языки должны быть добавлены в структуру локализации и зарегистрированы в `languages.js`.

---

### 2.4. Утилиты маршрутизации (`client/core/utils`)

##### `routeUtils.ts`

- **Назначение**: Утилиты для работы с маршрутами
- **Когда использовать**: При необходимости манипуляций с маршрутами

---

### 2.5. Типы (`client/core/types`)

Все типы из `client/core/types` должны быть использованы для типизации соответствующих сущностей:

- `themeTypes.ts` - типы для тем и стилей
- `notificationTypes.ts` - типы для уведомлений
- `types.ts` - общие типы приложения (RouteNode и т.д.)

**Требование**: **ЗАПРЕЩЕНО** дублировать типы из `client/core/types`, **обязательно** импортировать их.

---

## 3. Структура модулей (`client/modules`)

### 3.1. Эталонная структура модуля

Каждый модуль в `client/modules` должен следовать структуре, аналогичной `client/modules/main`:

```
client/modules/[module-name]/
├── components/          # Компоненты, специфичные для модуля
├── hooks/              # Хуки, специфичные для модуля
├── screens/            # Экраны модуля
├── store/              # Redux слайсы модуля
│   └── slice.ts        # Основной слайс модуля
├── theme/              # Темы и стили модуля
│   └── index.ts
├── types/              # Типы, специфичные для модуля
│   └── types.ts
├── utils/              # Утилиты, специфичные для модуля
└── routes.ts           # Маршруты модуля
```

### 3.2. Описание директорий модуля

#### 3.2.1. `components/`

- **Назначение**: Компоненты, используемые только в данном модуле
- **Требование**: Если компонент используется в нескольких модулях, он должен быть перенесен в `client/core/ui/components`

#### 3.2.2. `hooks/`

- **Назначение**: Пользовательские хуки для модуля
- **Требование**: Хуки общего назначения должны быть размещены в `client/core/services/hooks`

#### 3.2.3. `screens/`

- **Назначение**: Экраны (страницы) модуля
- **Требование**:
    - Каждый экран должен быть в отдельном файле
    - Имена файлов: camelCase с суффиксом (например: `first.tsx`, `second.tsx`)
    - Экспорт: именованный экспорт компонента (например: `export function FirstScreen()`)

#### 3.2.4. `store/`

- **Назначение**: Redux слайсы для управления состоянием модуля
- **Файлы**:
    - `slice.ts` - основной слайс модуля
- **Требование**:
    - Слайс должен быть зарегистрирован в `client/modules/stores.ts`
    - Использовать Redux Toolkit (`@reduxjs/toolkit`)

#### 3.2.5. `theme/`

- **Назначение**: Темы и стили, специфичные для модуля
- **Файлы**:
    - `index.ts` - экспорт тем модуля
- **Требование**:
    - Темы должны быть основаны на `templateTokens` из `client/core/ui/styles/themes.ts`
    - Регистрация через `styleProvider.addTheme()`

#### 3.2.6. `types/`

- **Назначение**: TypeScript типы для модуля
- **Файлы**:
    - `types.ts` - основные типы модуля
- **Требование**:
    - Типы общего назначения должны быть размещены в `client/core/types`
    - Избегать дублирования типов

#### 3.2.7. `utils/`

- **Назначение**: Утилиты, специфичные для модуля
- **Требование**: Утилиты общего назначения должны быть размещены в `client/core/services/utils`

#### 3.2.8. `routes.ts`

- **Назначение**: Определение маршрутов модуля
- **Формат**:

```typescript
import { RouteNode } from '../../core/types/types';
import { ScreenComponent } from './screens/screenComponent';

const moduleRoutes: RouteNode = {
    path: 'module-path',
    optionsNavigator: {
        type: 'tabs' | 'stack',
        options: {
            /* navigator options */
        },
    },
    children: [
        {
            path: 'screen-path',
            component: ScreenComponent,
        },
    ],
};

export default moduleRoutes;
```

- **Требование**:
    - Маршруты должны быть зарегистрированы в `client/modules/routes.ts`
    - Использовать тип `RouteNode` из `client/core/types/types`

---

### 3.3. Расширение структуры модуля

#### 3.3.1. Условия расширения

Структура модуля **может быть расширена** при выполнении следующих условий:

1. Существующая структура становится "тесной" для частей модуля
2. Логическое разделение улучшает читаемость и поддерживаемость
3. Расширение согласовано с архитектурой проекта

#### 3.3.2. Допустимые расширения

##### Вложенные директории в `components/`

```
components/
├── forms/              # Компоненты форм
├── lists/              # Компоненты списков
├── cards/              # Компоненты карточек
└── common/             # Общие компоненты модуля
```

##### Разделение `screens/` по функционалу

```
screens/
├── auth/               # Экраны аутентификации
├── profile/            # Экраны профиля
└── settings/           # Экраны настроек
```

##### Детализация `store/`

```
store/
├── slice.ts            # Основной слайс
├── selectors.ts        # Селекторы
├── thunks.ts           # Асинхронные экшены
└── types.ts            # Типы для store
```

##### Специфичные директории

```
├── api/                # API-клиенты модуля
├── constants/          # Константы модуля
├── models/             # Модели данных
├── services/           # Сервисы модуля
└── validators/         # Валидаторы
```

#### 3.3.3. Требования при расширении

1. **Документирование**: Новая структура должна быть задокументирована в README модуля
2. **Консистентность**: Расширения должны быть последовательными между модулями
3. **Минимализм**: Добавлять только необходимые директории
4. **Экспорты**: Обеспечить правильную реэкспорт в `index.ts` файлах

---

## 4. Регистрация модулей

### 4.1. Регистрация маршрутов

Все маршруты модулей должны быть зарегистрированы в `client/modules/routes.ts`:

```typescript
import mainRoutes from './main/routes';
import moduleRoutes from './module-name/routes';

export const routes = [
    mainRoutes,
    moduleRoutes,
    // ... другие модули
];
```

### 4.2. Регистрация Redux слайсов

Все слайсы должны быть зарегистрированы в `client/modules/stores.ts`:

```typescript
import { configureStore } from '@reduxjs/toolkit';
import mainSlice from './main/store/slice';
import moduleSlice from './module-name/store/slice';

export const store = configureStore({
    reducer: {
        main: mainSlice,
        moduleName: moduleSlice,
        // ... другие слайсы
    },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

---

## 5. Общие требования к коду

### 5.1. Кроссплатформенность

- **ОБЯЗАТЕЛЬНО** использовать адаптеры для платформо-специфичного функционала
- **ЗАПРЕЩЕНО** использовать `Platform.select()` без крайней необходимости
- Файлы с платформо-специфичным кодом: `.web.tsx`, `.native.tsx`, `.d.ts` (типы)

### 5.2. Типизация

- **ОБЯЗАТЕЛЬНО** использовать TypeScript для всех файлов (`.ts`, `.tsx`)
- **ЗАПРЕЩЕНО** использовать `any` без явной необходимости
- **ОБЯЗАТЕЛЬНО** типизировать пропсы компонентов, параметры функций и возвращаемые значения

### 5.3. Стилизация

- **ОБЯЗАТЕЛЬНО** использовать `useMemo` при создании стилей
- **ОБЯЗАТЕЛЬНО** использовать Theme из `useStyleContext()` для всех стилей
- **ЗАПРЕЩЕНО** хардкодить цвета, размеры и другие токены дизайн-системы

### 5.4. Производительность

- **ОБЯЗАТЕЛЬНО** использовать `useMemo` и `useCallback` для оптимизации
- **ОБЯЗАТЕЛЬНО** использовать `React.memo` для компонентов-листьев
- **ЗАПРЕЩЕНО** создавать функции и объекты внутри render без `useMemo`/`useCallback`

### 5.5. Архитектура

- Следовать принципу единственной ответственности (Single Responsibility Principle)
- Избегать циклических зависимостей
- Максимально переиспользовать код через композицию

### 5.6. Конфигурация окружения

- Все env-переменные описываются в `.env.example`
- Прямое использование process.env запрещено
- Доступ к конфигу — только через configService

---

## 6. Приоритеты использования инструментов

При выборе решения для задачи следовать следующему порядку приоритетов:

1. **Встроенные компоненты и сервисы из `client/core`** (наивысший приоритет)
2. Компоненты и утилиты из других модулей проекта
3. Сторонние библиотеки, широко используемые в проекте (если уже установлены)
4. Новые сторонние библиотеки (требуют согласования, наименьший приоритет)

### 6.1. Примеры

#### Вместо установки новой библиотеки для уведомлений:

❌ **НЕ ДЕЛАТЬ**: `npm install react-native-toast-message`  
✅ **ДЕЛАТЬ**: Использовать `notificationProvider.pushNotify()`

#### Вместо установки новой библиотеки для модальных окон:

❌ **НЕ ДЕЛАТЬ**: `npm install react-native-modal`  
✅ **ДЕЛАТЬ**: Использовать компоненты `Modal` или `ModalCard` из `interfaceComponents`

#### Вместо прямого использования `fetch`:

❌ **НЕ ДЕЛАТЬ**: `fetch(url).then(res => res.json())`  
✅ **ДЕЛАТЬ**: Использовать `fetchRequest` из `client/core/services/connection`

#### Вместо прямого использования `localStorage`:

❌ **НЕ ДЕЛАТЬ**: `localStorage.setItem('key', JSON.stringify(value))`  
✅ **ДЕЛАТЬ**: `storageService.set('key', value)`

---

## 7. Контроль соблюдения требований

### 7.1. Code Review

- Все pull request'ы должны проверяться на соответствие данным требованиям
- Использование сторонних библиотек вместо встроенных инструментов - основание для отклонения PR

### 7.2. Рефакторинг

- При обнаружении нарушений требований в существующем коде необходимо создать задачу на рефакторинг
- Приоритет рефакторинга: высокий для критических нарушений (использование запрещенных методов)

### 7.3. Расширение функционала

- Перед добавлением новой библиотеки:
    1. Проверить наличие функционала в `client/core`
    2. Рассмотреть возможность расширения существующих инструментов
    3. Обосновать необходимость новой зависимости
    4. Получить одобрение архитектора проекта

---

## 8. Заключение

Соблюдение данных технических требований обеспечивает:

- Единообразие кодовой базы
- Упрощение поддержки и развития проекта
- Минимизацию количества зависимостей
- Кроссплатформенность и переиспользование кода
- Высокую производительность приложения

Все разработчики **обязаны** следовать данным требованиям. При возникновении вопросов или предложений по улучшению - обращаться к архитектору проекта.

---

**Версия документа**: 1.0  
**Дата создания**: 2025-12-15  
**Статус**: Действующий
